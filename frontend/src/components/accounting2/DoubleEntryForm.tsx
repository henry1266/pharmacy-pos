import React, { useState, useEffect, useMemo } from 'react';
import {
  Box,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  TextField,
  IconButton,
  Button,
  Typography,
  Alert,
  Autocomplete,
  Chip,
  Paper,
  Tooltip,
  ListSubheader
} from '@mui/material';
import {
  Add as AddIcon,
  Delete as DeleteIcon,
  Balance as BalanceIcon,
  CheckCircle as CheckCircleIcon,
  Error as ErrorIcon,
  ArrowForward,
  Business as BusinessIcon,
  Category as CategoryIcon
} from '@mui/icons-material';
import { useAppSelector } from '../../hooks/redux';

export interface AccountingEntryFormData {
  accountId: string;
  debitAmount: number;
  creditAmount: number;
  description: string;
}

interface DoubleEntryFormProps {
  entries: AccountingEntryFormData[];
  onChange: (entries: AccountingEntryFormData[]) => void;
  organizationId?: string;
}

interface AccountOption {
  _id: string;
  name: string;
  code: string;
  accountType: string;
  normalBalance: 'debit' | 'credit';
  organizationId?: string;
  parentId?: string;
}


export const DoubleEntryForm: React.FC<DoubleEntryFormProps> = ({
  entries,
  onChange,
  organizationId
}) => {
  const { accounts } = useAppSelector(state => state.account2 || { accounts: [] });
  const { organizations } = useAppSelector(state => state.organization || { organizations: [] });

  // ÈÅéÊøæÂèØÁî®ÁöÑÊúÉË®àÁßëÁõÆ
  const availableAccounts: AccountOption[] = accounts.filter(account =>
    account.isActive && (!organizationId || account.organizationId === organizationId)
  );

  // ÊúÉË®àÁßëÁõÆÈ°ûÂûãÈÅ∏È†Ö
  const accountTypeOptions = [
    { value: 'asset', label: 'Ë≥áÁî¢', color: '#4caf50' },
    { value: 'liability', label: 'Ë≤†ÂÇµ', color: '#f44336' },
    { value: 'equity', label: 'Ê¨äÁõä', color: '#2196f3' },
    { value: 'revenue', label: 'Êî∂ÂÖ•', color: '#ff9800' },
    { value: 'expense', label: 'Ë≤ªÁî®', color: '#9c27b0' }
  ];

  // Âª∫Á´ãÈöéÂ±§ÂºèÊúÉË®àÁßëÁõÆÈÅ∏È†Ö
  const hierarchicalAccountOptions = useMemo(() => {
    console.log('üîÑ ÈáçÊñ∞Ë®àÁÆó hierarchicalAccountOptionsÔºåÂèØÁî®ÁßëÁõÆÊï∏:', availableAccounts.length);
    const options: any[] = [];
    
    // ÊåâÊ©üÊßãÂàÜÁµÑ
    const accountsByOrg = availableAccounts.reduce((acc, account) => {
      const orgId = account.organizationId || 'personal';
      if (!acc[orgId]) acc[orgId] = [];
      acc[orgId].push(account);
      return acc;
    }, {} as Record<string, AccountOption[]>);

    // ÁÇ∫ÊØèÂÄãÊ©üÊßãÂª∫Á´ãÈöéÂ±§ÁµêÊßã
    Object.entries(accountsByOrg).forEach(([orgId, orgAccounts]) => {
      const organization = organizations.find(org => org._id === orgId);
      const orgName = organization?.name || 'ÂÄã‰∫∫Â∏≥Êà∂';
      
      // Ê∑ªÂä†Ê©üÊßãÊ®ôÈ°å
      options.push({
        type: 'header',
        id: `org-${orgId}`,
        label: orgName,
        icon: 'organization'
      });

      // ÊåâÊúÉË®àÁßëÁõÆÈ°ûÂûãÂàÜÁµÑ
      const accountsByType = orgAccounts.reduce((acc, account) => {
        if (!acc[account.accountType]) acc[account.accountType] = [];
        acc[account.accountType].push(account);
        return acc;
      }, {} as Record<string, AccountOption[]>);

      // ÁÇ∫ÊØèÂÄãÊúÉË®àÁßëÁõÆÈ°ûÂûãÂª∫Á´ãÁØÄÈªû
      accountTypeOptions.forEach(typeOption => {
        const typeAccounts = accountsByType[typeOption.value] || [];
        if (typeAccounts.length > 0) {
          // Ê∑ªÂä†ÁßëÁõÆÈ°ûÂûãÊ®ôÈ°å
          options.push({
            type: 'header',
            id: `${orgId}-${typeOption.value}`,
            label: `„ÄÄ${typeOption.label}`,
            icon: 'category'
          });

          // Âª∫Á´ãÁà∂Â≠êÈöéÂ±§ÁµêÊßã
          const buildAccountHierarchy = (accounts: AccountOption[], parentId: string | null = null, level: number = 0): void => {
            const filteredAccounts = accounts.filter(account => {
              if (parentId === null) {
                return !account.parentId;
              }
              return account.parentId === parentId;
            });

            filteredAccounts
              .sort((a, b) => a.code.localeCompare(b.code))
              .forEach(account => {
                // Á¢∫‰øùÊØèÂÄãÁßëÁõÆÈÅ∏È†ÖÈÉΩÊúâÁ©©ÂÆöÁöÑÁµêÊßã
                options.push({
                  type: 'account',
                  _id: account._id,
                  name: account.name,
                  code: account.code,
                  accountType: account.accountType,
                  normalBalance: account.normalBalance,
                  organizationId: account.organizationId,
                  parentId: account.parentId,
                  displayName: `${'„ÄÄ'.repeat(level + 2)}${account.code} - ${account.name}`,
                  level: level + 2
                });

                // ÈÅûÊ≠∏ËôïÁêÜÂ≠êÁßëÁõÆ
                buildAccountHierarchy(accounts, account._id, level + 1);
              });
          };

          buildAccountHierarchy(typeAccounts);
        }
      });
    });

    console.log('‚úÖ hierarchicalAccountOptions Ë®àÁÆóÂÆåÊàêÔºåÁ∏ΩÈÅ∏È†ÖÊï∏:', options.length);
    console.log('üìã ÁßëÁõÆÈÅ∏È†ÖÁØÑ‰æã:', options.filter(opt => opt.type === 'account').slice(0, 3));
    return options;
  }, [availableAccounts, organizations, organizationId]);

  // Á¢∫‰øùËá≥Â∞ëÊúâÂÖ©ÂÄãÁ©∫ÂàÜÈåÑ
  React.useEffect(() => {
    if (entries.length === 0) {
      const defaultEntries: AccountingEntryFormData[] = [
        {
          accountId: '',
          debitAmount: 0,
          creditAmount: 0,
          description: ''
        },
        {
          accountId: '',
          debitAmount: 0,
          creditAmount: 0,
          description: ''
        }
      ];
      onChange(defaultEntries);
    }
  }, [entries.length, onChange]);

  // Ë®àÁÆóÂÄüË≤∏Á∏ΩÈ°ç
  const totalDebit = entries.reduce((sum, entry) => sum + (entry.debitAmount || 0), 0);
  const totalCredit = entries.reduce((sum, entry) => sum + (entry.creditAmount || 0), 0);
  const difference = Math.abs(totalDebit - totalCredit);
  const isBalanced = difference < 0.01;

  // Êñ∞Â¢ûÂàÜÈåÑ
  const addEntry = () => {
    const newEntry: AccountingEntryFormData = {
      accountId: '',
      debitAmount: 0,
      creditAmount: 0,
      description: ''
    };
    onChange([...entries, newEntry]);
  };

  // Âà™Èô§ÂàÜÈåÑ
  const removeEntry = (index: number) => {
    const newEntries = entries.filter((_, i) => i !== index);
    onChange(newEntries);
  };

  // Êõ¥Êñ∞ÂàÜÈåÑ
  const updateEntry = (index: number, field: keyof AccountingEntryFormData, value: any) => {
    console.log('üîÑ updateEntry Ë¢´Ë™øÁî®:', { index, field, value, currentValue: entries[index]?.[field] });
    
    const newEntries = [...entries];
    const currentEntry = newEntries[index];
    
    if (!currentEntry) {
      console.warn('‚ö†Ô∏è updateEntry: Êâæ‰∏çÂà∞ÊåáÂÆöÁ¥¢ÂºïÁöÑÂàÜÈåÑ:', index);
      return;
    }

    // Êõ¥Êñ∞ÊåáÂÆöÊ¨Ñ‰Ωç
    newEntries[index] = {
      ...currentEntry,
      [field]: value
    };

    // Â¶ÇÊûúÊòØÈáëÈ°çÊ¨Ñ‰ΩçÔºåÁ¢∫‰øùÂè¶‰∏ÄÂÄãÈáëÈ°çÁÇ∫ 0
    if (field === 'debitAmount' && value > 0) {
      newEntries[index].creditAmount = 0;
      console.log('üí∞ Ë®≠ÂÆöÂÄüÊñπÈáëÈ°çÔºåÊ∏ÖÈô§Ë≤∏ÊñπÈáëÈ°ç:', { debitAmount: value });
    } else if (field === 'creditAmount' && value > 0) {
      newEntries[index].debitAmount = 0;
      console.log('üí∞ Ë®≠ÂÆöË≤∏ÊñπÈáëÈ°çÔºåÊ∏ÖÈô§ÂÄüÊñπÈáëÈ°ç:', { creditAmount: value });
    }

    // Â¶ÇÊûúÊòØÁßëÁõÆÈÅ∏ÊìáËÆäÊõ¥ÔºåË®òÈåÑË©≥Á¥∞Ë≥áË®ä
    if (field === 'accountId') {
      const selectedAccount = hierarchicalAccountOptions.find(opt =>
        opt.type === 'account' && opt._id === value
      );
      console.log('üè¶ ÁßëÁõÆÈÅ∏ÊìáËÆäÊõ¥:', {
        index,
        oldAccountId: currentEntry.accountId,
        newAccountId: value,
        accountName: selectedAccount?.name || 'Êú™Áü•',
        accountCode: selectedAccount?.code || 'Êú™Áü•'
      });
    }

    console.log('‚úÖ updateEntry ÂÆåÊàêÔºåÊñ∞ÁöÑÂàÜÈåÑÁãÄÊÖã:', newEntries[index]);
    onChange(newEntries);
  };

  // Âø´ÈÄüÂπ≥Ë°°ÂäüËÉΩ
  const quickBalance = () => {
    if (entries.length < 2) return;

    const newEntries = [...entries];
    const lastEntry = newEntries[newEntries.length - 1];
    
    if (totalDebit > totalCredit) {
      lastEntry.creditAmount = totalDebit - (totalCredit - lastEntry.creditAmount);
      lastEntry.debitAmount = 0;
    } else if (totalCredit > totalDebit) {
      lastEntry.debitAmount = totalCredit - (totalDebit - lastEntry.debitAmount);
      lastEntry.creditAmount = 0;
    }

    onChange(newEntries);
  };

  // Ë®àÁÆó‰∫§ÊòìÊµÅÂêë
  const getTransactionFlow = (currentIndex: number) => {
    const currentEntry = entries[currentIndex];
    if (!currentEntry.accountId || (currentEntry.debitAmount === 0 && currentEntry.creditAmount === 0)) {
      return null;
    }

    // ÂæûÈöéÂ±§ÂºèÈÅ∏È†Ö‰∏≠ÊâæÂà∞Áï∂ÂâçÊúÉË®àÁßëÁõÆ
    const currentAccount = hierarchicalAccountOptions.find(opt =>
      opt.type === 'account' && opt._id === currentEntry.accountId
    );
    if (!currentAccount) return null;

    // ÊâæÂà∞Â∞çÊñπÁßëÁõÆÔºàÊúâÁõ∏ÂèçÈáëÈ°çÁöÑÂàÜÈåÑÔºâ
    const counterpartEntries = entries.filter((entry, index) => {
      if (index === currentIndex || !entry.accountId) return false;
      
      // Â¶ÇÊûúÁï∂ÂâçÂàÜÈåÑÊòØÂÄüÊñπÔºåÊâæË≤∏ÊñπÂàÜÈåÑÔºõÂèç‰πã‰∫¶ÁÑ∂
      if (currentEntry.debitAmount > 0 && entry.creditAmount > 0) return true;
      if (currentEntry.creditAmount > 0 && entry.debitAmount > 0) return true;
      
      return false;
    });

    if (counterpartEntries.length === 0) return null;

    // ÂèñÁ¨¨‰∏ÄÂÄãÂ∞çÊñπÁßëÁõÆ
    const counterpartEntry = counterpartEntries[0];
    const counterpartAccount = hierarchicalAccountOptions.find(opt =>
      opt.type === 'account' && opt._id === counterpartEntry.accountId
    );
    if (!counterpartAccount) return null;

    const hasDebit = currentEntry.debitAmount > 0;
    
    return (
      <Box sx={{ display: 'flex', alignItems: 'center', py: 0.5 }}>
        {hasDebit ? (
          // ÂÄüÊñπÔºöÂ∞çÊñπÁßëÁõÆ -> Áï∂ÂâçÁßëÁõÆ
          <>
            <Chip
              label={counterpartAccount.name}
              size="small"
              color="secondary"
              sx={{ fontSize: '0.65rem', height: 20, mr: 0.5 }}
            />
            <ArrowForward sx={{ fontSize: 14, color: 'primary.main', mx: 0.25 }} />
            <Chip
              label={currentAccount.name}
              size="small"
              color="primary"
              sx={{ fontSize: '0.65rem', height: 20, ml: 0.5 }}
            />
          </>
        ) : (
          // Ë≤∏ÊñπÔºöÁï∂ÂâçÁßëÁõÆ -> Â∞çÊñπÁßëÁõÆ
          <>
            <Chip
              label={currentAccount.name}
              size="small"
              color="primary"
              sx={{ fontSize: '0.65rem', height: 20, mr: 0.5 }}
            />
            <ArrowForward sx={{ fontSize: 14, color: 'primary.main', mx: 0.25 }} />
            <Chip
              label={counterpartAccount.name}
              size="small"
              color="secondary"
              sx={{ fontSize: '0.65rem', height: 20, ml: 0.5 }}
            />
          </>
        )}
      </Box>
    );
  };

  return (
    <Box>
      {/* ÂàÜÈåÑË°®Ê†º */}
      <TableContainer component={Paper} variant="outlined">
        <Table>
          <TableHead>
            <TableRow>
              <TableCell width="35%">ÊúÉË®àÁßëÁõÆ</TableCell>
              <TableCell width="18%">‰∫§ÊòìÊµÅÂêë</TableCell>
              <TableCell width="13%">ÂÄüÊñπÈáëÈ°ç</TableCell>
              <TableCell width="13%">Ë≤∏ÊñπÈáëÈ°ç</TableCell>
              <TableCell width="16%">ÊëòË¶Å</TableCell>
              <TableCell width="5%">Êìç‰Ωú</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {entries.map((entry, index) => (
              <TableRow key={index}>
                {/* ÊúÉË®àÁßëÁõÆÈÅ∏Êìá */}
                <TableCell>
                  <Autocomplete
                    size="small"
                    options={hierarchicalAccountOptions}
                    getOptionLabel={(option) => {
                      if (option.type === 'header') return option.label;
                      return option.displayName || `${option.code} - ${option.name}`;
                    }}
                    value={hierarchicalAccountOptions.find(opt => opt.type === 'account' && opt._id === entry.accountId) || null}
                    onChange={(_, newValue) => {
                      if (newValue && newValue.type === 'account') {
                        console.log('üîÑ ÁßëÁõÆÈÅ∏ÊìáËÆäÊõ¥:', {
                          from: entry.accountId,
                          to: newValue._id,
                          accountName: newValue.name
                        });
                        updateEntry(index, 'accountId', newValue._id || '');
                      } else if (newValue === null) {
                        // ËôïÁêÜÊ∏ÖÈô§ÈÅ∏ÊìáÁöÑÊÉÖÊ≥Å
                        console.log('üîÑ Ê∏ÖÈô§ÁßëÁõÆÈÅ∏Êìá:', entry.accountId);
                        updateEntry(index, 'accountId', '');
                      }
                    }}
                    getOptionDisabled={(option) => option.type === 'header'}
                    isOptionEqualToValue={(option, value) => {
                      // Á¢∫‰øùÊ≠£Á¢∫ÁöÑÂÄºÊØîËºÉÈÇèËºØ
                      if (option.type === 'header' || value.type === 'header') return false;
                      return option._id === value._id;
                    }}
                    renderInput={(params) => (
                      <TextField
                        {...params}
                        placeholder="ÈÅ∏ÊìáÊúÉË®àÁßëÁõÆ"
                        error={!entry.accountId}
                      />
                    )}
                    renderOption={(props, option) => {
                      if (option.type === 'header') {
                        return (
                          <ListSubheader
                            key={option.id}
                            sx={{
                              display: 'flex',
                              alignItems: 'center',
                              gap: 1,
                              fontWeight: 'bold',
                              color: option.icon === 'organization' ? 'primary.main' : 'text.primary',
                              backgroundColor: option.icon === 'organization' ? 'primary.50' : 'grey.50'
                            }}
                          >
                            {option.icon === 'organization' && <BusinessIcon fontSize="small" />}
                            {option.icon === 'category' && <CategoryIcon fontSize="small" />}
                            {option.label}
                          </ListSubheader>
                        );
                      }
                      
                      return (
                        <Box component="li" {...props} key={option._id}>
                          <Box sx={{ width: '100%' }}>
                            <Typography variant="body2" sx={{ fontWeight: 'medium' }}>
                              {option.displayName}
                            </Typography>
                            <Typography variant="caption" color="text.secondary">
                              {option.accountType} | Ê≠£Â∏∏È§òÈ°çÔºö{option.normalBalance === 'debit' ? 'ÂÄüÊñπ' : 'Ë≤∏Êñπ'}
                            </Typography>
                          </Box>
                        </Box>
                      );
                    }}
                    groupBy={(option) => {
                      if (option.type === 'header') return '';
                      return ''; // ‰∏ç‰ΩøÁî® groupByÔºåÂõ†ÁÇ∫ÊàëÂÄëÂ∑≤Á∂ìÁî® ListSubheader ËôïÁêÜÂàÜÁµÑ
                    }}
                  />
                </TableCell>

                {/* ‰∫§ÊòìÊµÅÂêë */}
                <TableCell>
                  {getTransactionFlow(index) || (
                    <Typography variant="caption" color="text.disabled">
                      -
                    </Typography>
                  )}
                </TableCell>

                {/* ÂÄüÊñπÈáëÈ°ç */}
                <TableCell>
                  <TextField
                    size="small"
                    type="number"
                    value={entry.debitAmount || ''}
                    onChange={(e) => updateEntry(index, 'debitAmount', parseFloat(e.target.value) || 0)}
                    placeholder="0.00"
                    inputProps={{ min: 0, step: 0.01 }}
                    disabled={entry.creditAmount > 0}
                    sx={{
                      '& input': {
                        textAlign: 'right'
                      }
                    }}
                  />
                </TableCell>

                {/* Ë≤∏ÊñπÈáëÈ°ç */}
                <TableCell>
                  <TextField
                    size="small"
                    type="number"
                    value={entry.creditAmount || ''}
                    onChange={(e) => updateEntry(index, 'creditAmount', parseFloat(e.target.value) || 0)}
                    placeholder="0.00"
                    inputProps={{ min: 0, step: 0.01 }}
                    disabled={entry.debitAmount > 0}
                    sx={{
                      '& input': {
                        textAlign: 'right'
                      }
                    }}
                  />
                </TableCell>

                {/* ÊëòË¶Å */}
                <TableCell>
                  <TextField
                    size="small"
                    fullWidth
                    value={entry.description}
                    onChange={(e) => updateEntry(index, 'description', e.target.value)}
                    placeholder="ÂàÜÈåÑÊëòË¶Å"
                  />
                </TableCell>

                {/* Êìç‰ΩúÊåâÈàï */}
                <TableCell>
                  <Tooltip title="Âà™Èô§ÂàÜÈåÑ">
                    <IconButton
                      size="small"
                      onClick={() => removeEntry(index)}
                      disabled={entries.length <= 1}
                      color="error"
                    >
                      <DeleteIcon />
                    </IconButton>
                  </Tooltip>
                </TableCell>
              </TableRow>
            ))}

            {/* Á∏ΩË®àË°å */}
            <TableRow sx={{ bgcolor: 'grey.50' }}>
              <TableCell>
                <Typography variant="subtitle2">Á∏ΩË®à</Typography>
              </TableCell>
              <TableCell>
                {/* ‰∫§ÊòìÊµÅÂêëÊ¨Ñ‰Ωç - Á©∫ÁôΩ */}
              </TableCell>
              <TableCell>
                <Typography variant="subtitle2" sx={{ textAlign: 'right' }}>
                  NT$ {totalDebit.toLocaleString()}
                </Typography>
              </TableCell>
              <TableCell>
                <Typography variant="subtitle2" sx={{ textAlign: 'right' }}>
                  NT$ {totalCredit.toLocaleString()}
                </Typography>
              </TableCell>
              <TableCell colSpan={2}>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                  <Typography variant="body2" color={isBalanced ? 'success.main' : 'error.main'}>
                    {isBalanced ? '‚úì ÂÄüË≤∏Âπ≥Ë°°' : `‚úó Â∑ÆÈ°çÔºöNT$ ${difference.toLocaleString()}`}
                  </Typography>
                  {!isBalanced && (
                    <Button
                      size="small"
                      variant="outlined"
                      onClick={quickBalance}
                      startIcon={<BalanceIcon />}
                      disabled={entries.length < 2}
                      sx={{ ml: 2 }}
                    >
                      Âø´ÈÄüÂπ≥Ë°°
                    </Button>
                  )}
                </Box>
              </TableCell>
            </TableRow>
          </TableBody>
        </Table>
      </TableContainer>

      {/* Êñ∞Â¢ûÂàÜÈåÑÊåâÈàï */}
      <Box sx={{ mt: 2, display: 'flex', justifyContent: 'center' }}>
        <Button
          variant="outlined"
          startIcon={<AddIcon />}
          onClick={addEntry}
        >
          Êñ∞Â¢ûÂàÜÈåÑ
        </Button>
      </Box>

      {/* ÊèêÁ§∫Ë®äÊÅØ */}
      {entries.length === 1 && (
        <Alert severity="warning" sx={{ mt: 2 }}>
          Ë§áÂºèË®òÂ∏≥ÈúÄË¶ÅËá≥Â∞ëÂÖ©Á≠ÜÂàÜÈåÑÔºåË´ãÊñ∞Â¢ûÊõ¥Â§öÂàÜÈåÑ
        </Alert>
      )}

    </Box>
  );
};

export default DoubleEntryForm;