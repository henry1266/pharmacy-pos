# 銷貨單號生成邏輯修復報告

## 問題描述

銷貨單的自動產生單號存在邏輯錯誤。當前單號為20250415001時，下一張單號應該是20250415002，但系統錯誤地生成為2025041515002。

## 問題分析

經過代碼分析，發現問題出在銷貨單號生成邏輯中，具體位於`backend/routes/sales.js`文件的POST路由處理函數中。

原始代碼：
```javascript
// 提取序號部分並加1
const sequence = parseInt(latestSale.saleNumber.substring(6)) + 1;
finalSaleNumber = `${datePrefix}${sequence.toString().padStart(3, '0')}`;
```

問題原因：
1. 使用固定的`substring(6)`來提取序號部分，這假設日期前綴總是6位數
2. 實際上日期前綴是8位數（YYYYMMDD格式），導致提取的序號包含了日期的一部分
3. 當提取的序號包含日期部分時，加1後生成的新單號就會出錯

## 解決方案

修改後的代碼：
```javascript
// 提取序號部分並加1 - 使用正則表達式確保正確提取序號
const match = latestSale.saleNumber.match(/^(\d{8})(\d{3})$/);
if (match && match[2]) {
  const sequence = (parseInt(match[2]) + 1) % 1000; // 確保序號在0-999範圍內
  finalSaleNumber = `${datePrefix}${sequence.toString().padStart(3, '0')}`;
} else {
  // 如果無法正確解析序號，從001開始
  finalSaleNumber = `${datePrefix}001`;
}
```

改進內容：
1. 使用正則表達式`/^(\d{8})(\d{3})$/`來正確提取序號部分，不再依賴固定位置
2. 添加`% 1000`操作，確保序號始終保持在0-999範圍內，解決序號進位問題
3. 添加錯誤處理，當無法正確解析序號時，從001開始重新計數

## 測試結果

創建了測試文件`test-sale-number.js`來驗證修復後的邏輯，測試了以下情況：

1. 正常情況：當前最新單號為20250415001，生成20250415002 ✓
2. 序號進位：當前最新單號為20250415999，生成20250415000 ✓
3. 無法解析序號：當前最新單號格式不正確，生成20250415001 ✓

測試結果表明修復後的邏輯能夠正確工作，解決了銷貨單號生成的問題。

## 總結

通過使用正則表達式替換固定位置提取，並添加適當的錯誤處理和序號範圍限制，成功修復了銷貨單號生成邏輯中的錯誤。修復後的代碼更加健壯，能夠正確處理各種情況，確保銷貨單號的連續性和正確性。
