# 銷貨單號生成邏輯修復報告

## 問題描述

用戶報告銷貨單號生成出現格式錯誤：
- 當前單號為 `20250415001`
- 下一張生成的單號錯誤為 `2025041515004`
- 預期的正確單號應為 `20250415002`

問題在於單號中間出現了重複的日期部分（`15`），導致單號格式不一致。

## 問題分析

經過代碼分析，發現問題出在 `OrderNumberGenerator` 組件的序號提取邏輯上。當數據庫中已有的銷貨單號格式不一致時（例如有些單號中間包含了重複的日期部分），原有的序號提取邏輯無法正確識別序號部分。

具體來說，原來的邏輯假設訂單號格式為「日期前綴 + 序號」，直接從日期前綴後開始提取序號部分。但當訂單號中間包含其他字符（如重複的日期部分）時，這種提取方式會將這些額外字符也當作序號的一部分，導致生成的新單號格式錯誤。

例如，對於單號 `2025041515004`：
- 日期前綴為 `20250415`
- 序號部分被錯誤提取為 `15004`（包含了重複的日期部分 `15`）
- 下一個序號計算為 `15004 + 1 = 15005`
- 生成的新單號為 `2025041515005`，而不是預期的 `20250415005`

## 解決方案

修改 `OrderNumberGenerator` 組件的序號提取邏輯，使用正則表達式匹配最後幾位數字作為序號部分，而不是簡單地從日期前綴後開始提取。這樣即使訂單號中間有其他字符，也能正確提取序號。

具體修改如下：

```javascript
// 修改前
const sequencePart = orderNumber.substring(datePrefix.length);
const sequence = parseInt(sequencePart);

// 修改後
const sequencePart = orderNumber.substring(datePrefix.length);
const regex = new RegExp(`\\d{${this.sequenceDigits}}$`);
const match = sequencePart.match(regex);

if (match) {
  const sequence = parseInt(match[0]);
  if (!isNaN(sequence)) {
    sequenceNumber = sequence + 1;
  }
}
```

這種方法能夠正確處理各種情況：
1. 正常情況：`20250415003` → 提取 `003` → 下一個序號 `004`
2. 日期重複：`2025041515003` → 提取 `003` → 下一個序號 `004`
3. 舊格式（短年份）：`250415003` → 無法匹配，使用默認序號 `001`
4. 用戶報告的問題：`2025041515004` → 提取 `004` → 下一個序號 `005`

## 測試結果

創建了測試文件 `test-simplified-sales-number.js` 來驗證修復效果，測試了以下情況：

1. 正常情況：
   - 最後一個訂單號：`20250415003`
   - 生成的訂單號：`20250415004` ✓

2. 異常情況（日期重複）：
   - 最後一個訂單號：`2025041515003`
   - 生成的訂單號：`20250415004` ✓

3. 舊格式（短年份）：
   - 最後一個訂單號：`250415003`
   - 生成的訂單號：`20250415001` ✓

4. 用戶報告的問題：
   - 最後一個訂單號：`2025041515004`
   - 生成的訂單號：`20250415005` ✓

所有測試都通過，表明修復後的銷貨單號生成邏輯能夠正確處理各種情況，包括用戶報告的具體問題。

## 總結

通過改進 `OrderNumberGenerator` 組件的序號提取邏輯，成功解決了銷貨單號生成中出現重複日期的問題。修復後的邏輯更加健壯，能夠處理各種可能的訂單號格式，確保生成的單號格式一致。這次修復不僅解決了當前的錯誤，也提高了系統的穩定性和可靠性。
