# 藥局POS系統

這是一個專為藥局設計的POS（銷售點）系統，提供藥品管理、供應商管理、銷售和庫存追蹤、記帳報表等功能。系統支援商品和藥品的分類管理，以及多種報表和數據分析工具。

## 功能特點

### 產品管理
藥局POS系統提供了全面的產品管理功能，能夠同時處理一般商品和專業藥品。系統針對這兩種不同類型的產品提供了專門的屬性和管理方式，使藥局能夠精確地追蹤和管理所有庫存項目。

商品和藥品在系統中被區分處理，商品包含國際條碼等零售特有屬性，而藥品則包含健保碼、健保價等醫療特有屬性。這種雙類型產品支援確保了藥局能夠同時管理處方藥品和非處方商品，提高了營運效率。

系統的庫存管理功能包括庫存水平即時監控、低庫存自動警告、庫存價值精確計算，以及按產品類型分類的詳細庫存報表。這些功能協助藥局維持最佳庫存水平，避免過度庫存或缺貨情況。

### 供應商管理
完善的供應商管理系統允許藥局建立和維護與供應商的關係。用戶可以添加、編輯和刪除供應商資料，並通過CSV批量匯入功能快速導入大量供應商數據。

系統存儲詳細的供應商信息，包括聯絡人、電話、電子郵件、地址、稅號和付款條件等。此外，系統還將供應商與相關的進貨單關聯起來，使藥局能夠追蹤與每個供應商的交易歷史。

### 銷售功能

系統提供了直覺式的銷售界面，使日常銷售操作變得簡單高效。界面設計考慮了藥局的特殊需求，支援多種支付方式，包括現金、信用卡、行動支付等。

所有銷售記錄都被系統自動追蹤，並可生成詳細的銷售報表。這些報表可以按日期、產品、客戶或其他參數進行過濾和分組，提供了對銷售趨勢的深入洞察。

### 進出貨管理
進出貨管理模組允許藥局創建和管理進貨單與出貨單。系統支援CSV批量匯入/匯出功能，大大提高了數據處理效率。

每個進出貨單都有狀態追蹤功能，使用戶能夠監控訂單從創建到完成的整個過程。系統還提供了庫存自動更新功能，確保庫存數據始終保持最新狀態。

### 報表系統
系統提供了多種報表類型，幫助藥局分析業務數據並做出明智決策。

銷售報表可以按日期、產品或客戶進行分組，提供銷售趨勢分析和產品銷售排名。這些報表幫助藥局識別熱銷產品和銷售模式。

庫存報表將商品與藥品分類顯示，提供庫存價值分析和低庫存警告。這些報表幫助藥局維持最佳庫存水平，避免過度庫存或缺貨情況。

記帳報表提供了多種圖表視圖（柱狀圖、折線圖、餅圖）和表格數據視圖，可按日期、班別或類別分組。系統支援CSV數據導出功能，並顯示摘要統計數據，幫助藥局追蹤財務狀況。

## 系統架構

### 整體架構設計
藥局POS系統採用現代化的 **Monorepo** 架構，使用 **pnpm workspace** 管理多個相關套件，確保代碼重用性和型別一致性。系統分為四個主要模組：

- **Frontend**: React + TypeScript 前端應用
- **Backend**: Node.js + Express 後端服務
- **Shared**: 共享型別定義和工具函數庫
- **OpenAPI**: API文檔規範作為單一真實來源(SSOT)

### 前端技術棧

前端採用現代化的 React 生態系統，提供優秀的用戶體驗：

- **React 18**: 核心前端框架，支援 Concurrent Features
- **TypeScript**: 提供完整的型別安全保障
- **Material-UI v5**: 現代化的 UI 組件庫，支援主題定制
- **Redux Toolkit**: 現代化的狀態管理解決方案
- **React Router v6**: 聲明式路由管理
- **Formik & Yup**: 表單處理和驗證
- **Chart.js & Recharts**: 數據可視化圖表庫
- **Framer Motion**: 流暢的動畫效果
- **Axios**: HTTP 客戶端，統一 API 調用
- **CRACO**: Create React App 配置覆蓋工具

### 後端技術棧
後端基於 Node.js 平台，提供穩定可靠的 API 服務：

- **Node.js**: 高效能的 JavaScript 運行環境
- **Express.js**: 輕量級 Web 框架
- **TypeScript**: 型別安全的後端開發
- **MongoDB**: NoSQL 文檔數據庫
- **Mongoose**: 優雅的 MongoDB ODM
- **JWT**: 無狀態身份驗證
- **Bcrypt.js**: 密碼加密
- **Multer**: 文件上傳處理
- **CSV-Parser**: CSV 文件處理
- **PDFKit**: PDF 報表生成
- **Day.js**: 輕量級日期處理庫
- **Swagger-UI-Express**: API文檔UI展示
- **Swagger-JSDoc**: 從JSDoc註解生成OpenAPI規範
- **@apidevtools/swagger-parser**: OpenAPI規範驗證與解析

### API文檔系統

藥局POS系統實現了基於OpenAPI 3.1的現代化API文檔系統，採用單一真實來源(SSOT)原則，確保API定義的一致性和可靠性。

#### OpenAPI 3.1作為SSOT

系統使用OpenAPI 3.1規範作為API定義的單一真實來源，所有API文檔和客戶端代碼都基於此規範生成，確保前後端一致性。

- **規範位置**: `/openapi/openapi.json`
- **規範版本**: OpenAPI 3.1.0
- **自動驗證**: 使用@apidevtools/swagger-parser確保規範符合標準

#### API文檔生成流程

1. **JSDoc註解**: 在路由和控制器中使用標準JSDoc註解定義API
2. **Swagger配置**: 在`backend/swagger.ts`中配置基本信息和共用模型
3. **自動生成**: 啟動服務時自動生成並驗證OpenAPI規範
4. **規範存儲**: 將驗證後的規範保存為`openapi.json`作為SSOT
5. **UI展示**: 使用Swagger UI在`/api-docs`路徑展示API文檔

#### 主要組件

- **模型定義**: 在`components/schemas`中定義共用數據模型
- **路徑定義**: 在`paths`中定義API端點和操作
- **安全方案**: 支援JWT Bearer認證和API Key認證
- **響應格式**: 標準化的成功和錯誤響應格式

#### 使用方法

1. **瀏覽API文檔**: 訪問`http://localhost:5000/api-docs`
2. **下載OpenAPI規範**: 從`http://localhost:5000/api-docs/json`獲取完整規範
3. **導入第三方工具**: 支援導入Postman、Insomnia等API測試工具

### Shared 模組架構
共享模組是系統的核心創新，提供統一的型別定義和工具函數：

#### 型別定義 (`types/`)
- **entities.ts**: 基礎實體型別（Product、Customer、Sale 等）
- **api.ts**: API 請求/回應型別定義
- **forms.ts**: 表單數據結構型別
- **accounting.ts**: 會計相關型別
- **business.ts**: 業務邏輯型別
- **models.ts**: 數據模型型別
- **utils.ts**: 工具函數型別

#### V2 統一 API 客戶端架構 (`services/`)
系統實現了基於 shared 模組的統一 API 客戶端架構，大幅減少代碼重複並提高一致性：

- **baseApiClient.ts**: 抽象基類，提供通用 CRUD 操作和錯誤處理
- **accountingApiClient.ts**: 會計服務 API 客戶端
- **productApiClient.ts**: 產品服務 API 客戶端
- **supplierApiClient.ts**: 供應商服務 API 客戶端
- **customerApiClient.ts**: 客戶服務 API 客戶端
- **salesApiClient.ts**: 銷售服務 API 客戶端
- **shippingOrderApiClient.ts**: 出貨訂單服務 API 客戶端
- **purchaseOrderApiClient.ts**: 採購訂單服務 API 客戶端
- **inventoryApiClient.ts**: 庫存服務 API 客戶端
- **employeeApiClient.ts**: 員工服務 API 客戶端

**V2 架構優勢**：
- **代碼重用**: 消除 80-85% 的重複 API 調用代碼
- **型別安全**: 完整的 TypeScript 支援和泛型設計
- **統一錯誤處理**: 標準化的錯誤處理機制
- **依賴注入**: 支援不同 HTTP 客戶端實現
- **可擴展性**: 新服務可輕鬆擴展基礎架構

#### 工具函數 (`utils/`)
- **dateUtils.ts**: 日期處理工具
- **stringUtils.ts**: 字串處理工具
- **numberUtils.ts**: 數字格式化工具
- **validationUtils.ts**: 數據驗證工具
- **workHoursUtils.ts**: 工時計算工具
- **roleUtils.ts**: 角色權限工具
- **accountingTypeConverters.ts**: 型別轉換工具

#### 常數和列舉 (`constants/`, `enums/`)
- **actionTypes.ts**: Redux Action 型別常數
- **index.ts**: 系統常數定義

#### Schema 驗證 (`schemas/`)
- 統一的數據驗證規則
- 支援前後端共用驗證邏輯

### 型別安全保障
系統實現了完整的型別安全機制：

1. **統一型別定義**: 前後端共用相同的型別定義
2. **型別轉換工具**: 提供安全的數據轉換函數
3. **自動型別檢查**: 使用 TypeScript 編譯時檢查
4. **一致性驗證**: 自動化腳本檢查型別一致性

## 安裝說明

### 系統需求
- **Node.js**: 18.x 或更高版本
- **pnpm**: 8.x 或更高版本（推薦使用 pnpm 作為套件管理器）
- **MongoDB**: 4.x 或更高版本
- **TypeScript**: 4.9 或更高版本
- **現代瀏覽器**: Chrome, Firefox, Edge 等

### 完整安裝步驟

#### 1. 克隆倉庫
```bash
git clone https://github.com/henry1266/pharmacy-pos.git
cd pharmacy-pos
```

#### 2. 安裝 pnpm（如果尚未安裝）
npm install -g pnpm

#### 3. 安裝所有依賴
pnpm install

#### 4. 建構 Shared 模組
```bash
# 建構共享型別定義
pnpm --filter shared build
```

#### 5. 配置數據庫
1. 確保 MongoDB 服務已啟動
2. 在 `backend/config` 目錄中創建或編輯 `default.json` 文件
3. 設置 MongoDB 連接字符串

#### 6. 啟動開發環境
pnpm run dev

### 快速啟動腳本
系統提供了便捷的安裝和啟動腳本：

#### Windows 用戶
```batch
setup.bat  # 首次安裝依賴
start.bat  # 啟動系統
```

#### Linux/Mac 用戶
```bash
chmod +x setup.sh  # 設置執行權限
./setup.sh         # 首次安裝依賴
```

### 開發工具指令

#### 建構專案

# 建構所有專案
pnpm run build

## 開發指南

### 開發規範

#### 代碼品質標準
藥局POS系統遵循嚴格的開發規範：

- **型別安全**: 所有代碼必須通過 TypeScript 嚴格模式檢查
- **代碼簡潔性**: 保持代碼簡潔、可讀、前後端一致
- **DRY 原則**: 避免重複代碼，優先使用 shared 模組
- **可讀性優先**: 優先考慮代碼可讀性而非過度簡潔
- **命名規範**: 使用有意義的變數和函數名稱
- **註釋原則**: 關鍵邏輯必須有 JSDoc 註釋說明

#### Monorepo 開發原則

1. **模組化設計**: 功能按模組劃分，避免循環依賴
2. **型別統一**: 所有型別定義統一放在 shared 模組
3. **工具函數共享**: 通用邏輯提取到 shared/utils
4. **版本同步**: 使用 workspace 協議管理內部依賴
5. **建構順序**: shared → backend → frontend

#### API文檔開發指南

藥局POS系統採用OpenAPI 3.1作為API文檔標準，開發者應遵循以下原則：

1. **JSDoc註解**: 所有API端點必須使用標準JSDoc註解，包含以下信息：
   - 端點描述 (`@description`)
   - 請求參數 (`@param`)
   - 響應格式 (`@returns`)
   - 錯誤處理 (`@throws`)

2. **模型定義**:
   - 共用模型定義在`backend/swagger.ts`的`components.schemas`中
   - 複雜模型使用`allOf`組合基礎模型
   - 所有模型屬性必須有描述和類型

3. **API版本管理**:
   - 主要版本變更需更新OpenAPI規範版本號
   - 不兼容變更必須在路徑中體現版本 (如`/api/v2/products`)
   - 兼容性變更可使用查詢參數指定版本

4. **測試與驗證**:
   - 新增或修改API後必須驗證OpenAPI規範
   - 使用Swagger UI手動測試API功能
   - 確保響應格式符合文檔定義

5. **文檔更新流程**:
   ```bash
   # 啟動開發服務器，自動生成最新API文檔
   pnpm --filter backend dev
   
   # 驗證API文檔是否正確
   # 訪問 http://localhost:5000/api-docs
   
   # 提交更新的OpenAPI規範
   git add openapi/openapi.json
   git commit -m "更新API文檔: [變更摘要]"
   ```


### 避免代碼耦合

為了維持系統的可維護性和可擴展性，開發者應遵循以下原則：

1. **單一責任原則**: 每個組件只負責一件事
2. **資料注入設計**: UI組件只處理數據展示，不處理業務邏輯
3. **避免雙向耦合**: 子組件不應引用父層特定狀態或方法命名
4. **區分UI狀態與數據狀態**: 使用適當的狀態管理工具
5. **集中管理共用狀態**: 使用Redux或自定義hooks管理共享狀態
6. **統一錯誤處理**: 使用攔截器處理共通錯誤
7. **功能導向的資料夾設計**: 採用feature-based結構
8. **穩定的API層**: 所有API調用封裝在服務層
9. **延後抽象**: 只有在多處使用時才抽離為共用組件

## 使用指南

### API文檔使用

藥局POS系統提供了完整的API文檔，幫助開發者和使用者了解和使用系統API。

#### 訪問API文檔

1. **啟動系統**: 執行`pnpm run dev`啟動開發環境
2. **瀏覽文檔**: 在瀏覽器中訪問`http://localhost:5000/api-docs`
3. **探索API**: 使用Swagger UI界面瀏覽所有可用的API端點

#### API測試

Swagger UI提供了內建的API測試功能：

1. **選擇端點**: 點擊要測試的API端點展開詳情
2. **設置參數**: 填寫請求參數和請求體
3. **執行請求**: 點擊"Try it out"按鈕發送請求
4. **查看結果**: 查看響應狀態碼、響應頭和響應體

#### 整合第三方工具

API文檔支援與第三方工具整合：

1. **下載OpenAPI規範**: 從`http://localhost:5000/api-docs/json`獲取完整規範
2. **導入Postman**: 在Postman中選擇"Import" > "OpenAPI"，導入下載的規範
3. **導入Insomnia**: 在Insomnia中選擇"Import/Export" > "Import Data" > "From URL"，輸入API文檔URL

### 產品管理

產品管理模組是藥局POS系統的核心功能之一，允許用戶添加、編輯和刪除產品。使用此模組時，請按照以下步驟操作：

1. 在系統導航菜單中選擇「產品管理」
2. 點擊「新增產品」按鈕創建新產品
3. 在產品創建表單中，首先選擇產品類型（商品或藥品）
4. 根據選擇的產品類型，系統會顯示相應的字段：
   - 商品類型會顯示國際條碼、品牌等字段
   - 藥品類型會顯示健保碼、健保價、藥品分類等字段
5. 填寫產品的基本信息，如名稱、描述、價格等
6. 設置庫存相關參數，包括初始庫存量、最低庫存警告閾值等
7. 點擊「保存」按鈕完成產品創建

產品列表頁面提供了多種過濾和排序選項，幫助用戶快速找到所需產品。用戶可以按產品類型、庫存狀態、價格範圍等條件進行過濾，也可以按名稱、價格、庫存量等字段進行排序。

## FIFO庫存管理

系統實現了先進先出(FIFO)庫存管理方法，確保庫存價值計算的準確性和一致性。FIFO方法假設最早購入的庫存最先被售出，這種方法在藥品管理中尤為重要，因為藥品通常有有效期限制。

FIFO功能的主要特點包括：

- **批次追蹤**: 系統追蹤每批進貨的數量、成本和日期
- **自動計算**: 出貨時自動按FIFO原則計算成本和利潤
- **庫存分佈明細**: 顯示當前庫存的批次分佈情況
- **過程日誌**: 記錄FIFO計算過程，便於審計和問題排查
- **模擬查詢**: 允許用戶模擬不同出貨情況下的FIFO計算結果

在產品詳情頁面，用戶可以查看該產品的FIFO庫存分佈，了解每批庫存的進貨日期、數量和成本。這些信息對於庫存管理和定價決策非常有價值。

### FIFO 模擬計算 API

系統提供了強大的 FIFO 模擬計算 API，允許用戶根據健保碼和數量模擬計算出貨成本。這對於預估出貨成本、制定定價策略和進行財務規劃非常有用。

#### 健保碼 FIFO 模擬計算 API

**端點**: `/api/fifo/simulate-by-health-insurance/{healthInsuranceCode}/{quantity}`

**方法**: GET

**描述**: 根據健保碼和數量，使用 FIFO 邏輯計算出這個數量的成本並返回詳細結果。此 API 會考慮已經發生的銷售或出貨記錄，確保計算結果準確反映當前庫存狀況。

**參數**:
- `healthInsuranceCode` : 產品健保碼
- `quantity` : 出貨數量

**返回結果**:
```json
{
  "success": true,
  "productId": "產品ID",
  "productName": "產品名稱",
  "productCode": "產品代碼",
  "healthInsuranceCode": "健保碼",
  "quantity": 數量,
  "inventoryStats": {
    "purchaseQuantity": 進貨總數量,
    "shippingQuantity": 出貨總數量,
    "saleQuantity": 銷售總數量,
    "currentStock": 當前庫存數量
  },
   "additionalCost": 額外數量的成本
}
```

**使用範例**:
```
GET /api/fifo/simulate-by-health-insurance/AC48007100/28
```

此 API 會計算健保碼為 AC48007100 的產品出貨 28 個單位的 FIFO 成本。計算過程會考慮已經發生的出貨和銷售記錄，確保結果準確反映當前庫存狀況。

## 用戶角色與權限

系統定義了以下用戶角色，具有不同的權限級別：

- **admin**: 管理員，擁有最高權限，可以訪問和管理系統的所有功能，包括用戶管理、系統設置等。
- **pharmacist**: 藥師，可以執行大部分藥局相關操作，如銷售、庫存管理、藥品管理等，但無法訪問某些管理功能。
- **staff**: 員工，權限最低，通常僅限於執行基本銷售操作和查看報表，無法修改系統設置或管理用戶。

新用戶的預設角色是 `staff`。用戶角色可以在建立用戶時指定，或由管理員後續修改。系統實現了基於角色的訪問控制(RBAC)，確保用戶只能訪問其角色允許的功能。

## V2 統一 API 架構

### 架構概述

藥局POS系統實現了基於 shared 模組的統一 API 客戶端架構，這是系統現代化的重要里程碑。V2 架構將原本分散在各個前端服務中的重複代碼整合到共享模組中，實現了代碼重用和一致性。

### 核心組件

#### BaseApiClient 基礎架構

- **抽象基類**: 提供通用的 CRUD 操作模板
- **統一錯誤處理**: 標準化的 `handleApiError` 機制
- **HttpClient 介面**: 支援依賴注入的 HTTP 客戶端抽象
- **泛型支援**: 完整的 TypeScript 泛型設計

#### 已實現的 V2 服務

系統已完成所有核心業務服務的 V2 架構實現：

1. **會計服務** - 分類管理、交易記錄
2. **產品服務** - 產品管理、庫存追蹤
3. **供應商服務** - 供應商管理、採購關係
4. **客戶服務** - 客戶管理、購買歷史
5. **銷售服務** - 銷售統計、退貨處理
6. **出貨訂單服務** - 出貨管理、批量操作
7. **採購訂單服務** - 採購管理、供應商整合
8. **庫存服務** - 庫存記錄、統計分析
9. **員工服務** - 員工管理、權限控制

### 前端適配器模式

每個前端 V2 服務都採用統一的適配器模式：

```typescript
// 創建 axios 適配器
const axiosAdapter: HttpClient = {
  get: axios.get.bind(axios),
  post: axios.post.bind(axios),
  put: axios.put.bind(axios),
  delete: axios.delete.bind(axios),
};

// 創建 API 客戶端實例
const apiClient = createXxxApiClient(axiosAdapter);

// 直接匯出方法，實現零重複代碼
export const getAllItems = apiClient.getAllItems.bind(apiClient);
export const getItemById = apiClient.getItemById.bind(apiClient);
```

### 架構優勢

#### 技術優勢

- **型別安全**: 完整的 TypeScript 支援和編譯時檢查
- **一致性**: 統一的錯誤處理和響應格式處理
- **可擴展性**: 支援依賴注入和繼承架構
- **維護性**: 修改一次，所有服務受益

## 測試覆蓋率與品質保證

### 測試架構概述

系統採用全面的測試策略，涵蓋模型層、服務層、控制器層和工具函數，確保代碼品質和系統穩定性。所有測試使用 Jest 框架，支援 TypeScript，並實現了完整的 Mock 策略。

### 模型層測試 (Models) ✅

已完成所有核心業務模型的完整測試覆蓋：

#### 已完成測試的模型

1. **PurchaseOrder.test.ts** (33 個測試用例)
   - 採購訂單模型完整測試
   - 涵蓋 CRUD 操作、狀態管理、數據驗證
   - 包含複雜查詢、關聯數據、業務邏輯驗證
   - 測試通過率：100%

2. **Supplier.test.ts** (29 個測試用例)
   - 供應商模型完整測試
   - 涵蓋供應商管理、關聯查詢、數據完整性
   - 包含批量操作、搜尋功能、驗證規則
   - 測試通過率：100%

3. **Inventory.test.ts** (31 個測試用例)
   - 庫存模型完整測試
   - 涵蓋庫存追蹤、FIFO 計算、批次管理
   - 包含庫存異動、統計分析、警告機制
   - 測試通過率：100%

4. **Employee.test.ts** (29 個測試用例)
   - 員工模型完整測試
   - 涵蓋員工管理、角色權限、帳號關聯
   - 包含工時計算、排班管理、績效統計
   - 測試通過率：100%

### 服務層測試 (Services) ✅

已完成所有核心業務服務的完整測試覆蓋：

#### 已完成測試的服務

1. **AccountBalanceService.test.ts** (26 個測試用例)
   - 會計科目餘額計算服務
   - 涵蓋餘額計算、試算表生成、交易歷史
   - 包含複雜會計邏輯、多幣別處理、期間計算
   - 測試通過率：100%

2. **employeeAccountService.test.ts** (21 個測試用例)
   - 員工帳號管理服務
   - 涵蓋帳號創建、更新、刪除、解綁等功能
   - 包含權限驗證、數據同步、錯誤處理
   - 測試通過率：100%

3. **OptimizedProductService.test.ts** (25 個測試用例)
   - 優化產品服務
   - 涵蓋產品查詢、搜尋、庫存管理、統計分析
   - 包含性能優化驗證（lean() 查詢、並行查詢、批量操作）
   - 測試通過率：100%

4. **CacheService.test.ts** (19 個測試用例)
   - 快取服務管理
   - 涵蓋快取策略、過期機制、記憶體管理
   - 包含裝飾器模式、中介軟體整合
   - 測試通過率：100%

5. **PackageUnitService.test.ts** (30 個測試用例)
   - 包裝單位服務
   - 涵蓋單位轉換、驗證規則、層級管理
   - 包含複雜轉換邏輯、邊界條件處理
   - 測試通過率：100%

6. **AutoAccountingEntryService.test.ts** (12 個測試用例)
   - 自動會計分錄服務
   - 涵蓋自動分錄生成、會計規則應用
   - 包含複雜業務邏輯、多場景處理
   - 測試通過率：100%

7. **AccountingIntegrationService.test.ts** (已創建，待測試)
   - 會計整合服務
   - 涵蓋進貨單會計整合、自動分錄、傳統會計科目創建
   - 包含私有方法測試、邊界條件測試、整合測試

### 測試技術特色

#### 核心技術棧
- **Jest 測試框架**: 使用現代化的 Jest 測試環境
- **TypeScript 支援**: 所有測試都通過 TypeScript 嚴格類型檢查
- **MongoDB Memory Server**: 隔離的測試數據庫環境（已優化移除以避免衝突）
- **完整 Mock 策略**: 精確的依賴項模擬和隔離測試

#### 測試策略
- **單元測試**: 專注於單一功能模組的測試
- **整合測試**: 驗證服務間的協作流程
- **邊界條件測試**: 全面的極端情況處理驗證
- **錯誤處理測試**: 完整的異常情況測試覆蓋
- **性能優化驗證**: 確保查詢優化和批量操作正常工作
- **業務邏輯驗證**: 複雜業務規則的完整測試

#### 品質保證機制
- **代碼覆蓋率監控**: 持續追蹤測試覆蓋率指標
- **自動化測試執行**: CI/CD 整合的自動測試流程
- **Mock 實現一致性**: 統一的 Mock 策略和實現模式
- **測試數據管理**: 標準化的測試數據創建和清理

### 測試統計

#### 整體統計
- **模型層測試**: 122 個測試用例，100% 通過率
- **服務層測試**: 133+ 個測試用例，100% 通過率
- **總測試用例**: 255+ 個
- **整體通過率**: 100%
- **平均測試執行時間**: < 3 秒（單檔測試）
- **代碼覆蓋率**: 持續提升中

#### 技術債務解決
- **MongoDB 連接衝突**: 已解決多個測試檔案間的數據庫連接衝突
- **Mock 實現問題**: 統一並修復了所有 TypeScript Mock 類型問題
- **測試隔離性**: 確保每個測試用例的完全隔離執行
- **錯誤訊息一致性**: 修正測試期望與實際服務錯誤訊息的不一致

### 測試開發原則

1. **逐步推進策略**: 一次專注於一個服務的完整測試開發
2. **全面覆蓋原則**: 包含正常流程、錯誤處理、邊界條件
3. **性能驗證要求**: 確保所有優化特性正常工作
4. **類型安全保障**: 所有測試代碼都通過 TypeScript 嚴格檢查
5. **可維護性優先**: 清晰的測試結構和描述性的測試名稱
6. **隔離測試環境**: 每個測試用例完全獨立，避免相互影響
7. **真實場景模擬**: 測試用例盡可能模擬真實業務場景

### 下一階段測試計劃

#### 待完成測試模組
- **Controllers 層測試**: API 端點和請求處理邏輯
- **Middleware 測試**: 身份驗證、權限控制、錯誤處理中介軟體
- **Utils 工具函數測試**: 共用工具函數和輔助方法
- **Routes 路由測試**: 路由配置和端點映射
- **Integration 整合測試**: 端到端的業務流程測試

#### 測試品質提升目標
- **代碼覆蓋率**: 目標達到 90% 以上
- **測試執行效能**: 優化測試執行速度
- **測試報告完善**: 詳細的測試報告和覆蓋率分析
- **持續整合**: 完善 CI/CD 測試流程

## 技術特色

### Monorepo 架構優勢

- **型別安全**: 前後端共享型別定義，消除型別不一致問題
- **代碼重用**: 共享工具函數和業務邏輯，減少重複開發
- **統一管理**: 使用 pnpm workspace 統一管理依賴和建構流程
- **開發效率**: 一次修改，多處生效，提高開發和維護效率

### OpenAPI 3.1 規範優勢

- **API 一致性**: 使用OpenAPI 3.1作為單一真實來源(SSOT)
- **自動文檔**: 從代碼註解自動生成最新API文檔
- **開發者體驗**: 互動式Swagger UI提供API測試和探索功能
- **工具整合**: 支援與Postman、Insomnia等第三方工具整合
- **前後端協作**: 明確的API契約減少溝通成本和錯誤
- **版本控制**: API規範納入版本控制，追蹤API演進歷史

### 型別系統設計

- **漸進式型別化**: 支援從 JavaScript 逐步遷移到 TypeScript
- **嚴格模式**: Shared 模組採用 TypeScript 嚴格模式
- **型別轉換**: 提供安全的前後端數據轉換工具
- **自動檢查**: 自動化腳本確保型別一致性

### 現代化工具鏈

- **pnpm**: 高效能的套件管理器，支援 workspace
- **TypeScript**: 完整的型別安全保障
- **CRACO**: 靈活的 Create React App 配置
- **Concurrently**: 同時執行多個開發服務器
- **Swagger**: 現代化API文檔和測試工具

## 開發團隊

- Henry Chen - 項目負責人
- 藥局POS開發團隊

## 初次使用

sudo npm install -g pnpm
pnpm install
pnpm run build
