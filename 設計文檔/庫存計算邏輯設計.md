# 庫存計算邏輯設計

## ⚠️ **核心設計原則**

**重要：大包裝模式僅用於顯示和輸入便利性，所有數據存儲一律使用最小包裝單位（基礎單位），避免包裝規格變更時數據污染。**

## 1. 數據存儲策略

### 統一存儲原則
```typescript
// ✅ 正確：所有庫存數據統一以基礎單位存儲
interface InventoryRecord {
  product: string;
  quantity: number;        // 永遠以基礎單位存儲（如：粒、個、ml等）
  // ... 其他欄位
}

// ❌ 錯誤：不要存儲包裝單位數據
interface WrongInventoryRecord {
  product: string;
  boxQuantity: number;     // 不要這樣做
  stripQuantity: number;   // 不要這樣做  
  pillQuantity: number;    // 不要這樣做
}
```

### 包裝配置與數據分離
```typescript
// 包裝配置：可變更，不影響歷史數據
interface ProductPackageUnit {
  productId: string;
  unitName: string;        // "盒", "排", "粒"
  unitValue: number;       // 1000, 10, 1
  priority: number;        // 3, 2, 1
  isBaseUnit: boolean;     // false, false, true
  // 配置變更時間戳
  effectiveFrom: Date;     // 生效時間
  effectiveTo?: Date;      // 失效時間（支援歷史配置）
}

// 實際庫存：永遠以基礎單位存儲
interface Inventory {
  product: string;
  quantity: number;        // 統一基礎單位：1635（粒）
  date: Date;
}
```

## 2. 核心計算算法

### 顯示轉換算法（僅用於UI顯示）
```typescript
/**
 * 將基礎單位數量轉換為包裝單位顯示
 * 注意：這只是顯示邏輯，不影響數據存儲
 */
function convertToPackageDisplay(
  baseQuantity: number,           // 基礎單位數量（從數據庫讀取）
  packageUnits: ProductPackageUnit[]  // 當前包裝配置
): PackageDisplayResult {
  
  // 按優先級降序排序（從大包裝開始計算）
  const sortedUnits = packageUnits
    .filter(unit => unit.isActive)
    .sort((a, b) => b.priority - a.priority);
  
  let remainingQuantity = baseQuantity;
  const breakdown: PackageBreakdownItem[] = [];
  
  // 從最大包裝開始分解
  for (const unit of sortedUnits) {
    if (remainingQuantity >= unit.unitValue) {
      const quantity = Math.floor(remainingQuantity / unit.unitValue);
      remainingQuantity = remainingQuantity % unit.unitValue;
      
      breakdown.push({
        unitName: unit.unitName,
        quantity: quantity,
        unitValue: unit.unitValue
      });
    }
  }
  
  // 生成顯示文字：1盒 63排 5粒
  const displayText = breakdown
    .map(item => `${item.quantity}${item.unitName}`)
    .join(' ');
  
  return {
    baseQuantity,           // 原始基礎單位數量
    packageBreakdown: breakdown,
    displayText: displayText || '0'
  };
}
```

### 輸入轉換算法（轉換為基礎單位存儲）
```typescript
/**
 * 將用戶輸入的包裝單位轉換為基礎單位
 * 支援格式：
 * - "1盒 5排 3粒" → 1×1000 + 5×10 + 3×1 = 1053
 * - "2盒" → 2×1000 = 2000
 * - "1000" → 1000（直接輸入基礎單位）
 */
function convertToBaseUnit(
  input: string,
  packageUnits: ProductPackageUnit[]
): number {
  
  // 純數字輸入，視為基礎單位
  if (/^\d+$/.test(input.trim())) {
    return parseInt(input.trim());
  }
  
  let totalBaseQuantity = 0;
  const unitMap = new Map(packageUnits.map(u => [u.unitName, u.unitValue]));
  
  // 解析 "數字+單位" 格式
  const regex = /(\d+)([^\d\s]+)/g;
  let match;
  
  while ((match = regex.exec(input)) !== null) {
    const quantity = parseInt(match[1]);
    const unitName = match[2];
    
    if (unitMap.has(unitName)) {
      // 轉換為基礎單位累加
      totalBaseQuantity += quantity * unitMap.get(unitName)!;
    }
  }
  
  return totalBaseQuantity;
}
```

## 3. 庫存操作流程

### 庫存輸入流程
```typescript
// 用戶輸入：1盒 5排 3粒
const userInput = "1盒 5排 3粒";

// 1. 獲取產品包裝配置
const packageUnits = await getProductPackageUnits(productId);

// 2. 轉換為基礎單位
const baseQuantity = convertToBaseUnit(userInput, packageUnits);
// 結果：1053（粒）

// 3. 存儲到數據庫（統一基礎單位）
await createInventoryRecord({
  product: productId,
  quantity: baseQuantity,  // 1053
  type: 'purchase',
  // ... 其他欄位
});
```

### 庫存顯示流程
```typescript
// 1. 從數據庫讀取基礎單位數據
const inventory = await getInventoryByProduct(productId);
const totalBaseQuantity = inventory.reduce((sum, item) => sum + item.quantity, 0);
// 結果：1635（粒）

// 2. 獲取當前包裝配置
const packageUnits = await getProductPackageUnits(productId);

// 3. 轉換為包裝顯示
const displayResult = convertToPackageDisplay(totalBaseQuantity, packageUnits);
// 結果：{ displayText: "1盒 63排 5粒" }

// 4. 在UI中顯示
console.log(displayResult.displayText); // "1盒 63排 5粒"
```

## 4. 包裝配置變更處理

### 歷史配置支援
```typescript
interface ProductPackageUnit {
  // ... 其他欄位
  effectiveFrom: Date;     // 配置生效時間
  effectiveTo?: Date;      // 配置失效時間
  version: number;         // 配置版本號
}

/**
 * 獲取指定時間點的包裝配置
 * 用於歷史數據的正確顯示
 */
async function getPackageUnitsAtDate(
  productId: string, 
  date: Date
): Promise<ProductPackageUnit[]> {
  return await ProductPackageUnit.find({
    productId,
    effectiveFrom: { $lte: date },
    $or: [
      { effectiveTo: { $exists: false } },
      { effectiveTo: { $gte: date } }
    ]
  });
}
```

### 配置變更示例
```typescript
// 原配置：1盒=1000粒, 1排=10粒
// 新配置：1盒=500粒, 1排=5粒

// 歷史庫存記錄：1635粒（基礎單位，不變）
const historicalQuantity = 1635;

// 使用原配置顯示：1盒 63排 5粒
const oldDisplay = convertToPackageDisplay(historicalQuantity, oldPackageUnits);

// 使用新配置顯示：3盒 27排 0粒
const newDisplay = convertToPackageDisplay(historicalQuantity, newPackageUnits);

// 數據完整性：基礎單位數量始終為1635，不受配置變更影響
```

## 5. 數據完整性保證

### 驗證規則
```typescript
// 1. 庫存記錄驗證
function validateInventoryRecord(record: InventoryRecord): boolean {
  // 數量必須為正整數（基礎單位）
  return Number.isInteger(record.quantity) && record.quantity >= 0;
}

// 2. 包裝配置驗證
function validatePackageUnits(units: ProductPackageUnit[]): boolean {
  // 必須有且僅有一個基礎單位
  const baseUnits = units.filter(u => u.isBaseUnit);
  if (baseUnits.length !== 1) return false;
  
  // 基礎單位值必須為1
  if (baseUnits[0].unitValue !== 1) return false;
  
  // 所有單位值必須為正整數
  return units.every(u => Number.isInteger(u.unitValue) && u.unitValue > 0);
}
```

## 6. 性能優化

### 緩存策略
```typescript
// 包裝配置緩存（配置變更頻率低）
const packageUnitsCache = new Map<string, ProductPackageUnit[]>();

async function getCachedPackageUnits(productId: string): Promise<ProductPackageUnit[]> {
  if (!packageUnitsCache.has(productId)) {
    const units = await getProductPackageUnits(productId);
    packageUnitsCache.set(productId, units);
  }
  return packageUnitsCache.get(productId)!;
}

// 配置變更時清除緩存
function clearPackageUnitsCache(productId: string): void {
  packageUnitsCache.delete(productId);
}
```

## 7. 總結

1. **數據存儲**：統一使用基礎單位，確保數據一致性
2. **顯示邏輯**：動態轉換為包裝單位，提升用戶體驗
3. **輸入處理**：支援包裝單位輸入，自動轉換為基礎單位存儲
4. **配置管理**：支援包裝規格變更，不影響歷史數據
5. **性能優化**：合理使用緩存，減少數據庫查詢

這樣的設計確保了數據的完整性和一致性，同時提供了良好的用戶體驗。