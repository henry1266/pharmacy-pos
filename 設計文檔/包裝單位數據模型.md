# 包裝單位數據模型設計

## 1. 包裝單位模型 (ProductPackageUnit)

```typescript
interface ProductPackageUnit {
  _id: string;
  productId: string;           // 關聯的產品ID
  unitName: string;            // 包裝單位名稱 (如: "盒", "排", "粒")
  unitValue: number;           // 包裝單位數值 (如: 1000, 10, 1)
  priority: number;            // 優先級 (數字越大優先級越高，從大包裝開始計算)
  isBaseUnit: boolean;         // 是否為基礎單位 (最小單位，如"粒")
  isActive: boolean;           // 是否啟用
  createdAt: Date;
  updatedAt: Date;
}
```

## 2. 擴展產品模型

在現有的 BaseProduct 模型中新增：

```typescript
interface BaseProduct {
  // ... 現有欄位
  packageUnits?: ProductPackageUnit[];  // 包裝單位配置
  defaultDisplayUnit?: string;          // 預設顯示單位
  enablePackageMode?: boolean;          // 是否啟用包裝模式
}
```

## 3. 庫存顯示模型

```typescript
interface InventoryPackageDisplay {
  totalQuantity: number;                // 總數量 (基礎單位)
  packageBreakdown: PackageBreakdownItem[];  // 包裝分解
  displayText: string;                  // 顯示文字 "1盒 63排 5粒"
}

interface PackageBreakdownItem {
  unitName: string;                     // 單位名稱
  quantity: number;                     // 該單位的數量
  unitValue: number;                    // 該單位的數值
}
```

## 4. 使用範例

### 藥品包裝配置範例：
```json
{
  "productId": "64f1234567890abcdef12345",
  "packageUnits": [
    {
      "unitName": "盒",
      "unitValue": 1000,
      "priority": 3,
      "isBaseUnit": false
    },
    {
      "unitName": "排",
      "unitValue": 10,
      "priority": 2,
      "isBaseUnit": false
    },
    {
      "unitName": "粒",
      "unitValue": 1,
      "priority": 1,
      "isBaseUnit": true
    }
  ]
}
```

### 庫存顯示範例：
- **輸入**: 1635粒
- **輸出**: "1盒 63排 5粒"
- **計算邏輯**:
  1. 1635 ÷ 1000 = 1盒 (餘635)
  2. 635 ÷ 10 = 63排 (餘5)
  3. 5 ÷ 1 = 5粒 (餘0)

## 5. MongoDB Schema 設計

```javascript
// ProductPackageUnit Schema
const ProductPackageUnitSchema = new Schema({
  productId: {
    type: Schema.Types.ObjectId,
    ref: 'baseproduct',
    required: true,
    index: true
  },
  unitName: {
    type: String,
    required: true,
    trim: true
  },
  unitValue: {
    type: Number,
    required: true,
    min: 1
  },
  priority: {
    type: Number,
    required: true,
    min: 1
  },
  isBaseUnit: {
    type: Boolean,
    default: false
  },
  isActive: {
    type: Boolean,
    default: true
  }
}, {
  timestamps: true
});

// 複合索引：確保同一產品的單位名稱唯一
ProductPackageUnitSchema.index({ productId: 1, unitName: 1 }, { unique: true });
// 複合索引：確保同一產品的優先級唯一
ProductPackageUnitSchema.index({ productId: 1, priority: 1 }, { unique: true });
```

## 6. 資料驗證規則

1. **每個產品只能有一個基礎單位** (`isBaseUnit: true`)
2. **基礎單位的 unitValue 必須為 1**
3. **優先級必須唯一且連續** (1, 2, 3...)
4. **單位名稱在同一產品內必須唯一**
5. **unitValue 必須能被下一級單位整除**

## 7. 業務邏輯約束

```typescript
// 驗證包裝單位配置的合理性
function validatePackageUnits(units: ProductPackageUnit[]): boolean {
  // 1. 必須有且僅有一個基礎單位
  const baseUnits = units.filter(u => u.isBaseUnit);
  if (baseUnits.length !== 1) return false;
  
  // 2. 基礎單位的值必須為1
  if (baseUnits[0].unitValue !== 1) return false;
  
  // 3. 按優先級排序，檢查整除關係
  const sortedUnits = units.sort((a, b) => b.priority - a.priority);
  for (let i = 0; i < sortedUnits.length - 1; i++) {
    const current = sortedUnits[i];
    const next = sortedUnits[i + 1];
    if (current.unitValue % next.unitValue !== 0) return false;
  }
  
  return true;
}